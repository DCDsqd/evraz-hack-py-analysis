Отвечай на русском языке.\nПроверь структуру Python проекта на соответствие корпоративным требованиям. Проект должен удовлетворять следующим пунктам:\n\nКорневая структура:\n\nВ корне проекта должны быть следующие файлы:\n.gitignore\n.editorconfig\n.gitattributes\nREADME.md с кратким описанием проекта, указаниями по локальной настройке, запуску тестов, настройкам прав и групп.\nФайл pyproject.toml для конфигурации сборщиков, автоформаттеров и других инструментов.\nФайл setup.py для описания метаданных пакета и зависимостей.\nКаталог deployment/:\n\nСтруктура для CI/CD и конфигурации развертывания (совместно с девопсами).\nКаталог docs/:\n\nХранение технической документации, включая схемы (с использованием PlantUml для схем прецедентов, БД, развертывания и компонентов).\nДокументация по бизнес-процессам может храниться в отдельной wiki или внутри этого каталога.\nSwagger-документация для API генерируется автоматически через бэкенд-эндпоинты.\nКаталог components/:\n\nКаталог для разделения фронт- и бек-логики.\nКаталог demo_project_backend должен быть корневым каталогом для Python-модулей проекта.\nКаталог бэкенда должен быть оформлен как стандартный Python-пакет с использованием __init__.py.\nМодули и пакеты:\n\nКод должен быть организован по принципу Гексагональной архитектуры с разделением на слои:\nСлой приложения: бизнес-логика, сущности, сервисы, DTO.\nСлой адаптеров: интеграции с внешними сервисами, контроллеры, продьюсеры, консьюмеры.\nСлой композитов: инициализация компонентов, передача зависимостей, настройка процессов.\nРепозитории для работы с БД и код запросов.\nИспользование классов-наследников от BaseSettings (pydantic) для передачи настроек в разных частях приложения.\nКонфигурации:\n\nНаличие конфигов для разных частей системы (например, для базы данных, API, логирования).\nКонфигурирование логирования через стандартный модуль logging, с использованием пакета python-json-logger для JSON-формата.\nТестирование:\n\nПрисутствие юнит-тестов и интеграционных тестов.\nТесты должны быть организованы по структуре проекта, а файлы тестов должны соответствовать именам классов и методов (например, test_<class_name>_<case>).\nИспользование SQLite в ОЗУ для интеграционных тестов, мокинг адаптеров для юнит-тестов.\nСтруктура каталогов для тестов должна отражать структуру проекта.\nРабота с базой данных:\n\nРабота с базой данных через SQLAlchemy (использование императивного маппинга для сложных сущностей).\nВ репозиториях должны быть описаны таблицы, миграции и запросы.\nНазвания таблиц должны быть в snake_case, начинаться с маленькой буквы, использовать множественное число для сущностей и справочников.\nЛогирование:\n\nЛогирование должно быть настроено с использованием пакета logging и соответствующим форматом.\nНикаких print в основном коде проекта, только логирование через логгер.\nИспользование корректных уровней логирования (INFO, DEBUG, ERROR) и форматирования через шаблоны.\nДокументация к коду:\n\nДокстринги должны быть написаны по стандарту PEP-257.\nВсе важные модули, классы и методы должны иметь соответствующие докстринги.\nСтруктура проекта должна быть описана в README.md.\nРабота с асинхронностью:\n\nИспользование асинхронного кода обосновано только в случаях реальной потребности в IO-операциях.\nДля асинхронных задач используется библиотека gevent (с патчингом при старте).\nКонтейнеризация:\n\nЕсли используется Docker, должны быть файлы Dockerfile и docker-compose.yml с соответствующими конфигурациями.\nАвторизация и безопасность:\n\nВсе токены передаются в заголовке Authorization: Bearer <token> (используется JWT-токен).\nВалидация данных через pydantic модели в сервисах.